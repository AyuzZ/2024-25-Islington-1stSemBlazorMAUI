@page "/dashboard"
@using CredWatch.Models
@using CredWatch.Services
@inject ITransactionService transactionService
@inject IDebtService debtService
@inject AuthStateService authStateService
@inject NavigationManager navigationManager

<style>
    table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
    font-family: Arial, sans-serif;
    }

    th {
    background-color: #4CAF50;
    color: white;
    padding: 10px;
    text-align: left;
    font-weight: bold;
    border-bottom: 2px solid #ddd; 
    }

    td, th {
    padding: 8px 12px;
    border-bottom: 1px solid #ddd;
    }
</style>

<h3>Dashboard</h3>
<br />
<h4>Username: @loggedInUser.Username</h4>
<h4>Current Balance: @currentBalance</h4>
<br />

<h3>Totals</h3>
<p>Total Inflow: @totalInflow</p>
<p>Total Outflow: @totalOutflow</p>
<p>Pending Debt: @pendingDebt</p>
<p>Cleared Debt: @clearedDebt</p>
<br />
<div>
    <h4>Highest and Lowest</h4>
    <div>
        <label>Sort</label>
        <select @bind="sortDirection">
            <option value="Highest">Highest</option>
            <option value="Lowest">Lowest</option>
        </select>
    </div>
    <br />
    <table>
        <thead>
            <tr>
                <th>Id</th>
                <th>Category</th>
                <th>Tag</th>
                <th>Amount</th>
                <th>Created Date</th>
                <th>Title</th>
            </tr>
        </thead>
        <tbody>
            @if (sortedTransactions.Any())
            {
                @foreach (var transaction in sortedTransactions)
                {
                    <tr>
                        <th>@transaction.TransactionId</th>
                        <th>@transaction.CategoryId</th>
                        <th>@transaction.TagId</th>
                        <th>@transaction.Amount</th>
                        <th>@transaction.CreatedDate</th>
                        <th>@transaction.Title</th>
                    </tr>
                }
            }

        </tbody>
    </table>
</div>
<br />
<div>
    <h4>Pending Debts</h4>
    <table >
        <thead>
            <tr>
                <th>Id</th>
                <th>Category</th>
                <th>Tag</th>
                <th>Amount</th>
                <th>Created Date</th>
                <th>Title</th>
            </tr>
        </thead>
        <tbody>
            @if (pendingDebts.Any())
            {
                @foreach (var transaction in pendingDebts)
                {
                    <tr>
                        <th style="background-color: #AA0000;">@transaction.TransactionId</th>
                        <th style="background-color: #AA0000;">@transaction.CategoryId</th>
                        <th style="background-color: #AA0000;">@transaction.TagId</th>
                        <th style="background-color: #AA0000;">@transaction.Amount</th>
                        <th style="background-color: #AA0000;">@transaction.CreatedDate</th>
                        <th style="background-color: #AA0000;">@transaction.Title</th>
                    </tr>
                }
            }

        </tbody>
    </table>
</div>



@code {
    private User loggedInUser = new User();
    private double currentBalance;

    private List<Transaction> userTransactions = new List<Transaction>();
    private List<DashboardDisplayTransactionModel> dashboardDisplayTransactionModels = new List<DashboardDisplayTransactionModel>();

    private List<Transaction> creditDebitTransactions = new List<Transaction>();
    private List<Transaction> debtTransactions = new List<Transaction>();



    private List<DisplayDebtModel> debts = new List<DisplayDebtModel>();
    private List<DisplayDebtModel> pendingDebts = new List<DisplayDebtModel>();

    private IEnumerable<DashboardDisplayTransactionModel> filteredTransactions => FilterTransactions();
    private IEnumerable<DashboardDisplayTransactionModel> sortedTransactions => SortTransactions(filteredTransactions);

    private double totalInflow;
    private double totalInflowCount;
    private double totalOutflow;
    private double totalOutflowCount;
    private double pendingDebt;
    private double pendingDebtCount;
    private double clearedDebt;
    private double clearedDebtCount;

    private string sortDirection = "Highest"; //Default


    protected override async Task OnInitializedAsync()
    {
        await GetLoggedInUserDetailAsync();
        await GetLoggedInUsersTransactionsAsync();
        // separating debt from credit and debit (inflow and outflow)
        await SeparateDebtsFromOtherTransactions();
        // combining debt and its transaction to display debt model
        await GetDebtRecords();
        await GetPendingDebts();
        CalculateCurrentBalance();
        await ConvertToDTO(userTransactions);
    }

    private async Task GetLoggedInUserDetailAsync()
    {
        loggedInUser = authStateService.GetLoggedInUser();
        if (loggedInUser == null)
        {
            navigationManager.NavigateTo("/");
        }
    }

    private async Task GetLoggedInUsersTransactionsAsync()
    {
        // all transactions belonging to the logged in user
        userTransactions = await transactionService.GetUsersTransactionsAsync(loggedInUser.UserId);
    }

    private async Task ConvertToDTO(List<Transaction> userTransactions)
    {
        foreach (Transaction userTransaction in userTransactions)
        {
            DashboardDisplayTransactionModel dashboardDisplayTransactionModel = new DashboardDisplayTransactionModel(
                userTransaction.TransactionId, userTransaction.Title, userTransaction.Amount, 
                userTransaction.CategoryId, userTransaction.CreatedDate, userTransaction.TagId);
            dashboardDisplayTransactionModels.Add(dashboardDisplayTransactionModel);
        }
    }

    private async Task SeparateDebtsFromOtherTransactions()
    {
        debtTransactions = userTransactions.Where(t => t.CategoryId == "Debt").ToList();

        creditDebitTransactions = userTransactions.Where(t => t.CategoryId != "Debt").ToList();
    }


    private async Task GetDebtRecords()
    {
        foreach (Transaction debtTransaction in debtTransactions)
        {
            // setting attributes already present in transaction obj
            DisplayDebtModel displayDebtModel = new DisplayDebtModel(debtTransaction.TransactionId, debtTransaction.Title, debtTransaction.Amount,
                debtTransaction.CreatedDate, debtTransaction.Note, debtTransaction.TagId, debtTransaction.UserId, debtTransaction.CategoryId);

            Debt debt = await debtService.GetDebtByTransactionIdAsync(debtTransaction.TransactionId);

            //setting the rest of the attributes
            displayDebtModel.DebtId = debt.DebtId;
            displayDebtModel.Source = debt.Source;
            displayDebtModel.DueDate = debt.DueDate;
            displayDebtModel.Status = debt.Status;

            // adding to the list
            debts.Add(displayDebtModel);
        }
    }

    private async Task GetPendingDebts()
    {
        pendingDebts = debts.Where(t => t.Status == "Pending").ToList();

    }

    private void CalculateCurrentBalance()
    {
        totalInflow = (double)creditDebitTransactions.Where(t => t.CategoryId == "Credit").Sum(t => t.Amount);
        totalOutflow = (double)creditDebitTransactions.Where(t => t.CategoryId == "Debit").Sum(t => t.Amount);
        pendingDebt = (double)debts.Where(d => d.Status == "Pending").Sum(d => d.Amount);
        clearedDebt = (double)debts.Where(d => d.Status == "Cleared").Sum(d => d.Amount);

        currentBalance = totalInflow + pendingDebt - totalOutflow - clearedDebt;

    }

    private IEnumerable<DashboardDisplayTransactionModel> FilterTransactions()
    {
        var filtered = dashboardDisplayTransactionModels.AsQueryable();
        return filtered;
    }

    private IEnumerable<DashboardDisplayTransactionModel> SortTransactions(IEnumerable<DashboardDisplayTransactionModel> filteredTransactions)
    {
        return (sortDirection) switch
        {
            ("Highest") => filteredTransactions.OrderByDescending(t => t.Amount).Take(5),
            ("Lowest") => filteredTransactions.OrderBy(t => t.Amount).Take(5),
            _ => filteredTransactions
        };
    }

}
